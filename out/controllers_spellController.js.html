<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/spellController.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/spellController.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const express = require('express');
const hbs = require('express-handlebars').create({});
const spellModel = require('../models/spellModel');
const authenticator = require('./authenticationHelperController');
const router = express.Router();
const routeRoot = '/spells';
const logger = require('../logger');
const { DatabaseError, InvalidInputError, InvalidSessionError } = require('../models/errorModel');
const userModel = require('../models/userModel');
const classModel = require('../models/classModel');
const { getAllSchools } = require('../models/spellModel');
const url = require('url');
const characterModel = require('../models/characterModel');

/**
 * Gets a render object containing default values for the spell page and any fields passed in the additionalFields object
 * @param {Object} additionalFields an object containing additional fields specific to the method calling it.
 * @throws {DatabaseError} Thrown when an error occurs while reading from the database.
 */
async function getRenderObject(additionalFields, userId)
{
    const renderObject = {};
    renderObject.spellsActive = true;
    renderObject.pageLevelCss = 'css/spells.css';

    if (!userId) userId = 0;

    // Only get spells and stuff if there was no 500 error
    // First statement accounts for when no object was passed
    if (!additionalFields || additionalFields.status != 500)
    {
        try
        {
            // Still check in case 400 was thrown before 500
            renderObject.spells = await spellModel.getAllSpells(userId);
            renderObject.schools = await spellModel.getAllSchools();
            renderObject.Classes = await classModel.getAllClasses();
        }
        catch (error)
        {
            throw new DatabaseError('spellController', 'getRenderObject', `Failed to get spells or schools: ${ error }`);
        }
    }

    for (var field in additionalFields)
    {
        renderObject[field] = additionalFields[field];
    }

    // Make sure spells exist
    if (renderObject.spells)
        renderObject.spells = capitalizeSpells(renderObject.spells);

    return renderObject;
}

/**
 * Gets a url format to be used in a redirect.
 * @param {String} pathname The path to redirect to
 * @param {Object} queryObject The object to put in the query.
 * @returns A url format to use in a redirect
 */
function getUrlFormat(pathname, queryObject)
{
    return url.format({ pathname: pathname, query: queryObject });
}

/**
 * Adds a spell from the body of an http request to the database.
 * On a successful add, the spell is sent in the http response.
 * On a failure, a 400 status will be sent for bad input 
 * and a 500 status will be sent for a bad database connection.
 * @param {Object} request An http request object.
 * @param {Object} response An http response object.
 */
async function addSpell(request, response, sessionId)
{
    const spellToAdd = request.body;

    spellToAdd.Material = spellToAdd.Material == 'on' ? true : false;
    spellToAdd.Somatic = spellToAdd.Somatic == 'on' ? true : false;
    spellToAdd.Verbal = spellToAdd.Verbal == 'on' ? true : false;
    spellToAdd.Ritual = spellToAdd.Ritual == 'on' ? true : false;
    spellToAdd.Concentration = spellToAdd.Concentration == 'on' ? true : false;
    spellToAdd.Damage = spellToAdd.damageDice ? spellToAdd.Damage : null;

    spellToAdd.Classes = spellToAdd.ClassIds.split(',');
    if (spellToAdd.Classes.length == 1 &amp;&amp; spellToAdd.Classes[0] == '')
        spellToAdd.Classes = [];

    try
    {
        spellToAdd.UserId = await userModel.getUserIdFromSessionId(sessionId);
        username = await userModel.getUsernameFromSessionId(sessionId);
    } catch (error)
    {
        logger.error(error);
        response.status(500);
        response.redirect(getUrlFormat('/home', { error: 'Sorry, something went wrong while validating your login status.', status: 500 }));
    }

    spellModel.addSpell(spellToAdd)
        .then(async spellAddedSuccessfully =>
        {
            response.status(201);
            // Add a warning if the spell wasn't added properly
            let urlFormat;
                urlFormat = getUrlFormat(`/spells/id/${spellAddedSuccessfully.Id}`, { status: 201, confirmation: 'Successfully added spell!' });
            // Redirect to avoid refresh re-adding
            response.redirect(urlFormat);
        })
        .catch(async error =>
        {
            if (error instanceof InvalidInputError)
            {
                logger.error(`Failed to add new spell: ${ error.message }`);
                response.status(400);
                if (spellToAdd.Damage)
                {
                    const damageStuff = spellToAdd.Damage.split('d');
                    spellToAdd.damageDiceQuantity = damageStuff[0];
                    spellToAdd.damageDie = 'd' + damageStuff[1];
                }
                response.redirect(getUrlFormat('/spells/spellAddition', { error: `That spell couldn't be added due to invalid input: ${ error.message }`, status: 400, failedSpell: JSON.stringify(spellToAdd) }));
            }
            else if (error instanceof DatabaseError)
            {
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: `Sorry, a database error occured while trying to add the spell. Please wait a moment and try again.`, status: 500 }));
                logger.error(error);
            }
            else
            {
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: `Sorry, something went wrong.`, status: 500 }));
                logger.error(error);
            }
        });
}
router.post('/', (request, response) => authenticator.gateAccess(request, response, addSpell));

/**
 * Removes a spell which matching the id provided in the uri.
 * On a successful delete, the spells page is rerendered with the new spells listed.
 * On a failure, a 400 status will be sent for a bad id 
 * and a 500 status will be sent for a bad database connection.
 * @param {Object} request An http request object.
 * @param {Object} response An http response object.
 */
async function removeSpellById(request, response, sessionId)
{
    id = request.params.id;

    let userId;
    try
    {
        userId = await userModel.getUserIdFromSessionId(sessionId);
    }
    catch (error)
    {
        if (error instanceof InvalidSessionError)
        {
            logger.error(error);
            response.status(401);
            response.redirect(getUrlFormat('/spells', { error: 'You are not authorized to delete a spell. Please log in and try again.', status: 401 }));
        }
        else if (error instanceof DatabaseError)
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: 'Sorry, there was an issue authorizing your login status. Please wait a moment and try again.', status: 500 }));
        }
        else
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: 'Something went wrong.', status: 500 }));
        }

    }

    spellModel.removeSpellById(id, userId)
        .then(async spellDeleted =>
        {
            response.status(200);
            response.redirect(getUrlFormat('/spells', { confirmation: 'Successfully deleted spell.' }));
        })
        .catch(async error =>
        {
            if (error instanceof InvalidInputError)
            {
                logger.error(`Failed to delete spell: ${ error.message }`);
                response.status(400);
                response.redirect(getUrlFormat('/home', { error: `Failed to delete spell due to invalid input: ${ error.message }`, status: 400 }));
            }
            else if (error instanceof DatabaseError)
            {
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: `A database error was encountered while trying to delete the spell. Please wait a moment and try again.`, status: 500 }));
                logger.error(error);
            }
            else
            {
                logger.error(error);
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: 'Something went wrong.', status: 500 }));
            }
        });
}
router.delete('/id/:id', (request, response) => authenticator.gateAccess(request, response, removeSpellById));


/**
 * Gets all spells.
 * On a successful get, all the spells for a user are sent in the http response.
 * On a failure, a 500 status will be sent for a bad database connection. 
 * @param {Object} request An http request object.
 * @param {Object} response An http response object.
 */
async function showAllSpellsLoggedIn(request, response, username, userId)
{

    try
    {
        const currentRenderObj = { Classes: await classModel.getAllClasses(), username: username };

        // Add redirect query notifications
        const query = request.query;
        if (query.error)
            currentRenderObj.error = query.error;
        if (query.warning)
            currentRenderObj.warning = query.warning;
        if (query.confirmation)
            currentRenderObj.confirmation = query.confirmation;

        response.render('spells.hbs', await getRenderObject(currentRenderObj, userId));
    } catch (error)
    {
        if (error instanceof InvalidInputError)
        {
            logger.error(`Failed to delete spell: ${ error.message }`);
            response.status(400);
            response.redirect(getUrlFormat('/home', { error: `Failed to delete spell due to invalid input: ${ error.message }`, status: 400 }));
        }
        else if (error instanceof DatabaseError)
        {
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: `A database error was encountered while trying to delete the spell. Please wait a moment and try again.`, status: 500 }));
            logger.error(error);
        }
        else
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: 'Something went wrong.', status: 500 }));
        }
    }
}
/**
 * Gets all spells.
 * On a successful get, all the spells from the player's handbook are sent in the http response.
 * On a failure, a 500 status will be sent for a bad database connection. 
 * @param {Object} request An http request object.
 * @param {Object} response An http response object.
 */
async function showAllSpellsLoggedOut(request, response)
{

    try
    {
        const currentRenderObj = { Classes: await classModel.getAllClasses() };

        // Add redirect query notifications
        const query = request.query;
        if (query.error)
            currentRenderObj.error = query.error;
        if (query.warning)
            currentRenderObj.warning = query.warning;
        if (query.confirmation)
            currentRenderObj.confirmation = query.confirmation;


        response.render('spells.hbs', await getRenderObject(currentRenderObj));
    } catch (error)
    {
        if (error instanceof DatabaseError)
        {
            response.status(500);
            response.redirect(getUrlFormat('/home', {error: `Sorry, a database error was encountered while trying to get the spells. Please wait a moment and try again.`, status: 500 }));
            logger.error(error);
        }
        else
        {
            response.status(500);
            response.redirect(getUrlFormat('/home', {error: 'Sorry, something went wrong.', status: 500}));
            logger.error(error);
        }
    }
}
router.get('/', (request, response) => authenticator.loadDifferentPagePerLoginStatus(request, response, showAllSpellsLoggedIn, showAllSpellsLoggedOut));


/**
 * Gets all spells which match the filter provided in the request body.
 * On a successful get, all the spells matching the filter requirements
 *  are sent in the http response.
 * On a failure, a 400 status is sent for a bad filter, and a 
 * 500 status will be sent for a bad database connection. 
 * @param {Object} request An http request object.
 * @param {Object} response An http response object.
 */
async function showFilteredSpells(request, response, username, userId)
{
    filter = request.query;

    const characterId = filter.characterId;
    userId = userId ? userId : 0;
    filter.Level = filter.Level ? filter.Level : null;
    filter.SchoolId = filter.SchoolId ? filter.SchoolId : null;
    filter.Name = filter.Name ? filter.Name : null;
    filter.CastingTime = filter.CastingTime ? filter.CastingTime : null;
    filter.Verbal = filter.includeVerbal == 'on' ? filter.Verbal == 'on' : null;
    filter.Somatic = filter.includeSomatic == 'on' ? filter.Somatic == 'on' : null;
    filter.Material = filter.includeMaterial == 'on' ? filter.Material == 'on' : null;
    filter.Duration = filter.Duration ? filter.Duration : null;
    filter.EffectRange = filter.EffectRange ? filter.EffectRange : null;
    filter.Concentration = filter.includeConcentration == 'on' ? filter.Concentration == 'on' : null;
    filter.Ritual = filter.includeRitual == 'on' ? filter.Ritual == 'on' : null;
    filter.Classes = filter.ClassIds ? filter.ClassIds.split(',') : null;
    filter.HomebrewOnly = filter.includeHomebrew ? filter.Homebrew == 'on' : null;
    filter.Homebrew = filter.HomebrewOnly;

    try{
        if(characterId){
            filter.Classes = [(await characterModel.getCharacter(characterId, userId)).Class.Id];
        }
    }
    catch(error){
        if (error instanceof InvalidInputError) {
            logger.error(`Failed to get filtered list of spells: ${error.message}`);
            response.status(400)
            response.redirect(getUrlFormat('/home', {error: `Failed to get the filtered list of spells since the provided filter contained invalid data: ${error.message}`, status: 400, username: username }));
        }
        else if (error instanceof DatabaseError)
        {
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: `Sorry, a database error was encountered while trying to get the filtered list of spells. Please wait a moment and try again.`, status: 500, username: username }));
            logger.error(error);
        }
        else
        {
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: `Sorry, something went wrong.`, status: 500, username: username }));
            logger.error(error);
        }
    }

    spellModel.getSpellsWithSpecifications(filter.Level, filter.SchoolId, userId, filter.Name, filter.CastingTime, filter.Verbal, filter.Somatic, filter.Material, filter.Duration, filter.EffectRange, filter.Concentration, filter.Ritual, filter.Classes, filter.HomebrewOnly)
        .then(async filteredSpells =>
        {
            if (filter.characterId)
            {
                const character = await characterModel.getCharacter(characterId, userId);
                if ((await characterModel.getUserCharacters(userId)).map(character => character.Id).includes(Number(character.Id))){
                    filter.Class = await classModel.getClass(filter.Classes[0]);
                    response.status(200);
                    response.render('addSpellToCharacter.hbs', await getRenderObject({ characterId: characterId, character: character, spells: filteredSpells, filter: filter, username: username }, userId));
                }
                else
                {
                    response.status(400);
                    response.redirect(getUrlFormat('/home', { error: 'You are not authorized to add spells to that character.', status: 400 }));
                }
            }
            else
                response.render('spells.hbs', await getRenderObject({ spells: filteredSpells, filter: filter, Classes: await classModel.getAllClasses(), username: username }, userId));
        })
        .catch(async error => {
            if (error instanceof InvalidInputError) {
                logger.error(`Failed to get filtered list of spells: ${error.message}`);
                response.status(400)
                response.redirect(getUrlFormat('/home', {error: `Failed to get the filtered list of spells since the provided filter contained invalid data: ${error.message}`, status: 400, username: username }));
            }
            else if (error instanceof DatabaseError)
            {
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: `Sorry, a database error was encountered while trying to get the filtered list of spells. Please wait a moment and try again.`, status: 500, username: username }));
                logger.error(error);
            }
            else
            {
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: `Sorry, something went wrong.`, status: 500, username: username }));
                logger.error(error);
            }
        });
}
router.get('/filter', (request, response) => authenticator.loadDifferentPagePerLoginStatus(request, response, showFilteredSpells, showFilteredSpells));


/**
 * Gets the spell with the id provided in the uri.
 * On a successful get, the spell is sent in the http response.
 * On a failure, a 400 status is sent for a bad id, and a 
 * 500 status will be sent for a bad database connection. 
 * @param {Object} request An http request object.
 * @param {Object} response An http response object.
 */
async function showSpellWithId(request, response, username, userId)
{
    const id = request.params.id;

    userId = userId ? userId : 0;

    spellModel.getSpellById(id, userId)
        .then(async spell => { 
            if(spell.Damage == 'null')
                spell.Damage = null
            response.status(200);
            
            // For redirects
            const query = request.query;
            response.render('focusSpell.hbs', {error: query.error, warning: query.warning, confirmation: query.confirmation, username: username, spell: capitalizeSpells([spell])[0], spellsActive: true }) 
        })
        .catch(async error =>
        {
            if (error instanceof DatabaseError)
            {
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: `Sorry, we couldn't get the spell you wanted to focus on due to a server issue. Please try again in a moment.`, status: 500 }));
                logger.error(error);
            }
            else if (error instanceof InvalidInputError)
            {
                logger.error(`Failed to get spell: ${ error.message }`);
                response.status(400);
                response.redirect(getUrlFormat('/home', { error: `Sorry, we couldn't get the spell you wanted to focus on. You either do not have access to it or it doesn't exist.`, status: 400 }));
            }
            else
            {
                logger.error(error);
                response.status(500);
                response.redirect(getUrlFormat('/home', { error: 'Something went wrong', status: 500 }));
            }
        });
}
router.get('/id/:id', (request, response) => authenticator.loadDifferentPagePerLoginStatus(request, response, showSpellWithId, showSpellWithId));


/**
 * Edits the spell with the id provided in the uri to contain the
 * properties indicated in the request body. 
 * On a successful edit, a boolean value indicating whether a spell was 
 * updated with the provided id is sent in the response.
 * On a failure, a 400 status is sent for an invalid id, and a 500 status
 * is sent for database issues.
 * @param {Object} request An http request object.
 * @param {Object} response An http response object.
 */
async function editSpellWithId(request, response, sessionId)
{

    let userId;
    let username;
    try{
        userId = await userModel.getUserIdFromSessionId(sessionId);
        username = await userModel.getUsernameFromSessionId(sessionId);
    }
    catch (error)
    {
        if (error instanceof InvalidSessionError)
        {
            logger.error(error);
            response.status(401)
            response.redirect(getUrlFormat('/spells', {homeActive: true, username: username, error: 'You are not authorized to delete a spell. Please log in and try again.', status: 401}));
        }
        else if (error instanceof DatabaseError)
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', {homeActive: true, username: username, error: 'Sorry, there was an issue authorizing your login status. Please wait a moment and try again.', status: 500}));
        }
        else
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', {homeActive: true, username: username, error: 'Something went wrong.', status: 500}));
        }

    }

    const query = request.query;
    const id = query.spellId;
    const level = query.Level;
    const name = query.Name;
    const description = query.Description;
    const schoolId = query.SchoolId;
    const castingTime = query.CastingTime;
    const duration = query.Duration;
    let damage = query.Damage;
    let range = query.EffectRange;
    let somatic = query.Somatic;
    let verbal = query.Verbal;
    let material = query.Material;
    let materials = query.Materials;
    let concentration = query.Concentration;
    let ritual = query.Ritual;

    material = material == 'on' ? true : false
    materials = material ? materials : null;
    somatic = somatic == 'on' ? true : false
    verbal = verbal == 'on' ? true : false
    ritual = ritual == 'on' ? true : false
    concentration = concentration == 'on' ? true : false
    damage = query.damageDice ? damage : null;

    query.Classes = query.ClassIds.split(',')
    if (query.Classes.length == 1 &amp;&amp; query.Classes[0] == '')
        query.Classes = [];

    
    try{
        username = await userModel.getUsernameFromSessionId(sessionId);
        await spellModel.updateSpellById(id, userId, level, schoolId, description, name, castingTime, verbal, somatic, material, materials, duration, damage, range, concentration, ritual, query.Classes)
        response.redirect(getUrlFormat(`/spells/id/${id}`, {username: username, confirmation: 'Successfully edited spell'}));
        
    }catch( error) {
            if (error instanceof InvalidInputError) {
                logger.error(`Failed to get update spell with id ${id}: ${error.message}`);
                response.status(400)
                response.redirect(getUrlFormat(`/spells/editform/${id}`, { error: `The spell was not edited due to invalid input: ${error.message}`, status: 400 }))
            }
            else if (error instanceof DatabaseError) {
                response.status(500);
                response.redirect(getUrlFormat('/home', {homeActive: true, username: username, error: `Sorry, we couldn't get the spell you wanted to edit due to a server side issue. Please try again in a moment.`, status: 500 }));
                logger.error(error);
            }
            else{
                response.status(500);
                response.redirect(getUrlFormat('/home', {homeActive: true, username: username, error: 'Something went wrong', status: 500}));
                logger.error(error);
            }
    }

}
router.put('/', (request, response) => authenticator.gateAccess(request, response, editSpellWithId));

/**
 * Shows the spell edit page.
 * @param {Object} request The http request.
 * @param {Object} response The http response.
 * @param {String} sessionId The new session id of the user.
 */
async function showEditSpellPage(request, response, sessionId)
{

    let spellChoiceId = request.params.id;

    // Add redirect query notifications
    const query = request.query;
    let queryError;
    if (query.error)
        queryError = query.error;

    try
    {
        const userId = await userModel.getUserIdFromSessionId(sessionId);
        const spellToEdit = await spellModel.getSpellById(spellChoiceId, userId);
        // Can not edit a spell from the phb
        if (spellToEdit.UserId != userId)
            throw new InvalidInputError('spellController', 'showEditSpellPage', 'You can not edit a spell that you did not create.');

        if (spellToEdit.Damage)
        {
            const damageStuff = spellToEdit.Damage.split('d');
            spellToEdit.damageDiceQuantity = damageStuff[0];
            spellToEdit.damageDie = 'd' + damageStuff[1];
        }
        spellToEdit.Classes = spellToEdit.Classes.map(Class => Class.Id);
        let options = { error: queryError, schools: await spellModel.getAllSchools(), Classes: await classModel.getAllClasses(), username: await userModel.getUsernameFromSessionId(sessionId), spellsActive: true, spellToEdit: spellToEdit };
        response.status(200);
        response.render('spellEdit.hbs', options);
    } catch (error)
    {
        if (error instanceof InvalidSessionError)
        {
            logger.error(error);
            response.status(401)
            response.redirect(getUrlFormat('/spells', {username: username, error: 'You are not authorized to edit a spell. Please log in and try again.', status: 401}));
        }
        else if (error instanceof DatabaseError)
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', {username: username,  error: 'Sorry, there was an issue authorizing your login status. Please wait a moment and try again.', status: 500}));
        }
        else if (error instanceof InvalidInputError)
        {
            logger.error(error);
            response.status(400);
            response.redirect(getUrlFormat('/spells', {username: username, error: 'The spell you attempted to edit was not found.', status: 400}));
        }
        else
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', {username: username, error: 'Something went wrong.', status: 500}));
        }
    }


}
router.get('/editform/:id', (request, response) => authenticator.gateAccess(request, response, showEditSpellPage));

/**
 * Displays the page used by users to add spells.
 * @param {Object} request An http request object
 * @param {Object} response An http response object
 * @param {String} sessionId The session id of the user trying to add a spell.
 */
async function getAddSpellForm(request, response, sessionId)
{

    let currentRenderObj;
    try
    {
        currentRenderObj = { username: await userModel.getUsernameFromSessionId(sessionId), schools: await getAllSchools(), Classes: await classModel.getAllClasses(), spellsActive: true };
    }
    catch (error)
    {
        if (error instanceof InvalidSessionError)
        {
            logger.error(error);
            response.status(401);
            response.redirect(getUrlFormat('/spells', { error: 'You are not authorized to delete a spell. Please log in and try again.', status: 401 }));
        }
        else if (error instanceof DatabaseError)
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: 'Sorry, there was an issue authorizing your login status. Please wait a moment and try again.', status: 500 }));
        }
        else
        {
            logger.error(error);
            response.status(500);
            response.redirect(getUrlFormat('/home', { error: 'Something went wrong.', status: 500 }));
        }
    }

    // Add redirect query notifications
    const query = request.query;
    if (query.error)
        currentRenderObj.error = query.error;
    if (query.warning)
        currentRenderObj.warning = query.warning;
    if (query.confirmation)
        currentRenderObj.confirmation = query.confirmation;
    if (query.failedSpell)
        currentRenderObj.failedSpell = JSON.parse(query.failedSpell);

    response.render('spellCreation.hbs', currentRenderObj);

}
router.get('/spelladdition', (request, response) => authenticator.gateAccess(request, response, getAddSpellForm));

hbs.handlebars.registerHelper('equals', (arg1, arg2) =>
{
    if (!arg1 &amp;&amp; !arg2)
        return true;
    return arg1 == arg2;
});
hbs.handlebars.registerHelper('numEquals', (arg1, arg2) =>
{
    if ((arg1 == null || arg2 == null) &amp;&amp; arg1 != arg2)
        return false;
    return arg1 == arg2;
});
hbs.handlebars.registerHelper('in', (item, container) =>
{
    return container ? container.includes(item) : false;
});
hbs.handlebars.registerHelper('stringIn', (item, container) =>
{
    return container ? container.includes(String(item)) || container.includes(item) : false;
});
hbs.handlebars.registerHelper('trim', (text, length = 200) =>
{
    if (text.fn(this).length &lt; length)
        return text.fn(this);
    return text.fn(this).substring(0, length) + '...';
});
hbs.handlebars.registerHelper('isNoneOf', (arg1, arg2) =>
{
    if (!arg1)
        arg1 = null;
    return !JSON.parse(arg2).includes(arg1);
});
hbs.handlebars.registerHelper('isEmpty', (array) =>
{

    return array.length == 0;
});


/**
 * Capitalizes the first letter of every word in each spell name, and the school of the spell.
 * @param {Object} spells The list of spells to capitalize.
 * @returns {Array} the list of spells after being capitalized.
 */
function capitalizeSpells(spells)
{
    for (let spell of spells)
    {
        // Return the spells if the spell is null
        let words;
        try
        {
            words = spell.Name.split(' ');
        } catch (error)
        {
            return spells;
        }

        if (words.length != 0)
        {

            // Capitalize this
            let newName = '';
            words.forEach(word =>
            {
                if (word.length == 1)
                    newName += word.toUpperCase();
                else
                    newName += `${ word[0].toUpperCase() }${ word.substring(1, word.length) } `;
            });

            if (newName.length > 1)
                spell.Name = newName.substring(0, newName.length - 1);
            else
                spell.Name = newName;
            spell.school = `${ spell.school[0].toUpperCase() }${ spell.school.substring(1, spell.school.length) }`;

        }

    }

    return spells;

}

module.exports = {
    router,
    routeRoot
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="DatabaseError.html">DatabaseError</a></li><li><a href="IncorrectPasswordError.html">IncorrectPasswordError</a></li><li><a href="InvalidInputError.html">InvalidInputError</a></li><li><a href="InvalidPasswordError.html">InvalidPasswordError</a></li><li><a href="InvalidSessionError.html">InvalidSessionError</a></li><li><a href="InvalidUsernameError.html">InvalidUsernameError</a></li><li><a href="UserAlreadyExistsError.html">UserAlreadyExistsError</a></li><li><a href="UserNotFoundError.html">UserNotFoundError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addCharacter">addCharacter</a></li><li><a href="global.html#addCharacterObject">addCharacterObject</a></li><li><a href="global.html#addExperiencePoints">addExperiencePoints</a></li><li><a href="global.html#addExpertiseController">addExpertiseController</a></li><li><a href="global.html#addItem">addItem</a></li><li><a href="global.html#addKnownSpell">addKnownSpell</a></li><li><a href="global.html#addProficiencyController">addProficiencyController</a></li><li><a href="global.html#addRemoveHp">addRemoveHp</a></li><li><a href="global.html#addSavingThrowProficiency">addSavingThrowProficiency</a></li><li><a href="global.html#addSkillExpertise">addSkillExpertise</a></li><li><a href="global.html#addSkillProficiency">addSkillProficiency</a></li><li><a href="global.html#addSpell">addSpell</a></li><li><a href="global.html#addSpellFromValues">addSpellFromValues</a></li><li><a href="global.html#addSpellToCharacter">addSpellToCharacter</a></li><li><a href="global.html#addUser">addUser</a></li><li><a href="global.html#authenticateSession">authenticateSession</a></li><li><a href="global.html#authenticateUser">authenticateUser</a></li><li><a href="global.html#buildSheet">buildSheet</a></li><li><a href="global.html#capitalizeSpells">capitalizeSpells</a></li><li><a href="global.html#changeQuantityItem">changeQuantityItem</a></li><li><a href="global.html#checkAbility">checkAbility</a></li><li><a href="global.html#checkAbilityScores">checkAbilityScores</a></li><li><a href="global.html#checkBackground">checkBackground</a></li><li><a href="global.html#checkCharacterId">checkCharacterId</a></li><li><a href="global.html#checkClass">checkClass</a></li><li><a href="global.html#checkEthics">checkEthics</a></li><li><a href="global.html#checkLevel">checkLevel</a></li><li><a href="global.html#checkMaxHitPoints">checkMaxHitPoints</a></li><li><a href="global.html#checkMorality">checkMorality</a></li><li><a href="global.html#checkName">checkName</a></li><li><a href="global.html#checkRace">checkRace</a></li><li><a href="global.html#checkSavingThrowProficiencies">checkSavingThrowProficiencies</a></li><li><a href="global.html#checkSkillId">checkSkillId</a></li><li><a href="global.html#checkUserID">checkUserID</a></li><li><a href="global.html#closeConnection">closeConnection</a></li><li><a href="global.html#connection">connection</a></li><li><a href="global.html#createAbilityScoreTable">createAbilityScoreTable</a></li><li><a href="global.html#createAbilityTable">createAbilityTable</a></li><li><a href="global.html#createBackgroundFeatureTable">createBackgroundFeatureTable</a></li><li><a href="global.html#createBackgroundTable">createBackgroundTable</a></li><li><a href="global.html#createClassFeatureTable">createClassFeatureTable</a></li><li><a href="global.html#createClassTable">createClassTable</a></li><li><a href="global.html#createEthicsTable">createEthicsTable</a></li><li><a href="global.html#createKnownSpellTable">createKnownSpellTable</a></li><li><a href="global.html#createMoralityTable">createMoralityTable</a></li><li><a href="global.html#createOwnedItemTable">createOwnedItemTable</a></li><li><a href="global.html#createPlayerCharacterTable">createPlayerCharacterTable</a></li><li><a href="global.html#createRaceTable">createRaceTable</a></li><li><a href="global.html#createRacialTraitTable">createRacialTraitTable</a></li><li><a href="global.html#createRecentCharactersCookie">createRecentCharactersCookie</a></li><li><a href="global.html#createSavingThrowBonusTable">createSavingThrowBonusTable</a></li><li><a href="global.html#createSavingThrowProficiencyTable">createSavingThrowProficiencyTable</a></li><li><a href="global.html#createSession">createSession</a></li><li><a href="global.html#createSkillExpertiseTable">createSkillExpertiseTable</a></li><li><a href="global.html#createSkillProficiencyTable">createSkillProficiencyTable</a></li><li><a href="global.html#createSkillTable">createSkillTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#dateTimeToMySqlFormat">dateTimeToMySqlFormat</a></li><li><a href="global.html#deleteCharacter">deleteCharacter</a></li><li><a href="global.html#deleteExpiredSessions">deleteExpiredSessions</a></li><li><a href="global.html#deleteSpellFromCharacter">deleteSpellFromCharacter</a></li><li><a href="global.html#doesTableHaveContent">doesTableHaveContent</a></li><li><a href="global.html#dropReliantTables">dropReliantTables</a></li><li><a href="global.html#dropTables">dropTables</a></li><li><a href="global.html#editSpellWithId">editSpellWithId</a></li><li><a href="global.html#gateAccess">gateAccess</a></li><li><a href="global.html#getAbilityIdFromName">getAbilityIdFromName</a></li><li><a href="global.html#getAbilityScores">getAbilityScores</a></li><li><a href="global.html#getAddSpellForm">getAddSpellForm</a></li><li><a href="global.html#getAllAbilities">getAllAbilities</a></li><li><a href="global.html#getAllBackgrounds">getAllBackgrounds</a></li><li><a href="global.html#getAllClasses">getAllClasses</a></li><li><a href="global.html#getAllEthics">getAllEthics</a></li><li><a href="global.html#getAllMoralities">getAllMoralities</a></li><li><a href="global.html#getAllRaces">getAllRaces</a></li><li><a href="global.html#getAllSchoolIds">getAllSchoolIds</a></li><li><a href="global.html#getAllSchools">getAllSchools</a></li><li><a href="global.html#getAllSkills">getAllSkills</a></li><li><a href="global.html#getAllSpells">getAllSpells</a></li><li><a href="global.html#getAllUserCharacters">getAllUserCharacters</a></li><li><a href="global.html#getBackground">getBackground</a></li><li><a href="global.html#getCharacter">getCharacter</a></li><li><a href="global.html#getClass">getClass</a></li><li><a href="global.html#getClassesObjectListFromSpellId">getClassesObjectListFromSpellId</a></li><li><a href="global.html#getClassIdFromName">getClassIdFromName</a></li><li><a href="global.html#getConnection">getConnection</a></li><li><a href="global.html#getCookieObjectFromRequestAndUserId">getCookieObjectFromRequestAndUserId</a></li><li><a href="global.html#getNameInternal">getNameInternal</a></li><li><a href="global.html#getRace">getRace</a></li><li><a href="global.html#getRenderObject">getRenderObject</a></li><li><a href="global.html#getSavingThrowBonuses">getSavingThrowBonuses</a></li><li><a href="global.html#getSavingThrowProficiencies">getSavingThrowProficiencies</a></li><li><a href="global.html#getSchoolsFromJSON">getSchoolsFromJSON</a></li><li><a href="global.html#getSkillExpertise">getSkillExpertise</a></li><li><a href="global.html#getSkillProficiencies">getSkillProficiencies</a></li><li><a href="global.html#getSpellById">getSpellById</a></li><li><a href="global.html#getSpellsWithSpecifications">getSpellsWithSpecifications</a></li><li><a href="global.html#getUrlFormat">getUrlFormat</a></li><li><a href="global.html#getUrlFormatHelper">getUrlFormatHelper</a></li><li><a href="global.html#getUserCharacters">getUserCharacters</a></li><li><a href="global.html#getUserIdFromSessionId">getUserIdFromSessionId</a></li><li><a href="global.html#getUsernameFromSessionId">getUsernameFromSessionId</a></li><li><a href="global.html#handleInvalidEndpoint">handleInvalidEndpoint</a></li><li><a href="global.html#hashPassword">hashPassword</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#isCharValid">isCharValid</a></li><li><a href="global.html#levelUp">levelUp</a></li><li><a href="global.html#lightSwitch">lightSwitch</a></li><li><a href="global.html#loadDifferentPagePerLoginStatus">loadDifferentPagePerLoginStatus</a></li><li><a href="global.html#login">login</a></li><li><a href="global.html#mysql">mysql</a></li><li><a href="global.html#populateBackgroundAndFeaturesTable">populateBackgroundAndFeaturesTable</a></li><li><a href="global.html#populateClassAndClassFeatureTables">populateClassAndClassFeatureTables</a></li><li><a href="global.html#populateRaceAndRacialTraitTables">populateRaceAndRacialTraitTables</a></li><li><a href="global.html#populateSpellTable">populateSpellTable</a></li><li><a href="global.html#reduceArrayToString">reduceArrayToString</a></li><li><a href="global.html#refreshSession">refreshSession</a></li><li><a href="global.html#removeAllExpertiseAndProficiencies">removeAllExpertiseAndProficiencies</a></li><li><a href="global.html#removeCharacter">removeCharacter</a></li><li><a href="global.html#removeItem">removeItem</a></li><li><a href="global.html#removeKnownSpell">removeKnownSpell</a></li><li><a href="global.html#removeSavingThrowProficiency">removeSavingThrowProficiency</a></li><li><a href="global.html#removeSession">removeSession</a></li><li><a href="global.html#removeSkillExpertise">removeSkillExpertise</a></li><li><a href="global.html#removeSkillProficiency">removeSkillProficiency</a></li><li><a href="global.html#removeSpellById">removeSpellById</a></li><li><a href="global.html#sendCharacter">sendCharacter</a></li><li><a href="global.html#sendToAddSpellPage">sendToAddSpellPage</a></li><li><a href="global.html#sendToCreatePage">sendToCreatePage</a></li><li><a href="global.html#sendToUpdateController">sendToUpdateController</a></li><li><a href="global.html#setAbilityScores">setAbilityScores</a></li><li><a href="global.html#setSavingThrowBonus">setSavingThrowBonus</a></li><li><a href="global.html#showAllSpellsLoggedIn">showAllSpellsLoggedIn</a></li><li><a href="global.html#showAllSpellsLoggedOut">showAllSpellsLoggedOut</a></li><li><a href="global.html#showEditSpellPage">showEditSpellPage</a></li><li><a href="global.html#showFilteredSpells">showFilteredSpells</a></li><li><a href="global.html#showSpecificBackground">showSpecificBackground</a></li><li><a href="global.html#showSpecificClass">showSpecificClass</a></li><li><a href="global.html#showSpellWithId">showSpellWithId</a></li><li><a href="global.html#uniqueList">uniqueList</a></li><li><a href="global.html#updateAC">updateAC</a></li><li><a href="global.html#updateCharacter">updateCharacter</a></li><li><a href="global.html#updateExp">updateExp</a></li><li><a href="global.html#updateHitpoints">updateHitpoints</a></li><li><a href="global.html#updateInitiative">updateInitiative</a></li><li><a href="global.html#updateLevel">updateLevel</a></li><li><a href="global.html#updateSpeed">updateSpeed</a></li><li><a href="global.html#updateSpellById">updateSpellById</a></li><li><a href="global.html#validateBackgroundId">validateBackgroundId</a></li><li><a href="global.html#validateClassId">validateClassId</a></li><li><a href="global.html#validateClassIds">validateClassIds</a></li><li><a href="global.html#validateMaterials">validateMaterials</a></li><li><a href="global.html#validatePassword">validatePassword</a></li><li><a href="global.html#validateRaceId">validateRaceId</a></li><li><a href="global.html#validateSpell">validateSpell</a></li><li><a href="global.html#validateSpellComponentBool">validateSpellComponentBool</a></li><li><a href="global.html#validateSpellDamage">validateSpellDamage</a></li><li><a href="global.html#validateSpellGenericString">validateSpellGenericString</a></li><li><a href="global.html#validateSpellId">validateSpellId</a></li><li><a href="global.html#validateSpellLevel">validateSpellLevel</a></li><li><a href="global.html#validateSpellName">validateSpellName</a></li><li><a href="global.html#validateSpellSchool">validateSpellSchool</a></li><li><a href="global.html#validateUser">validateUser</a></li><li><a href="global.html#validateUsername">validateUsername</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Thu May 19 2022 22:20:10 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
